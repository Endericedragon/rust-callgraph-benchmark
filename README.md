# Rust Call-Graph Generator Benchmark

A benchmark for call-graph generators that analyze programs written in Rust. This benchmark is a
collection of hopefully all the possible ways to call a function or a method within and across
package boundaries in Rust.

This benchmark aims to enable call-graph generator implementers to assess the soundness of
call-graphs generated by their tools. It can also serve as documentation of all the possible ways
functions and methods may be called in Rust code.

## Benchmark Structure

The benchmark is built around the **main** package, which contains a single binary crate. The
benchmark is organized in several packages, each one containing a subset of the available ways to
call a function/method. These packages are **static_dispatch**, **dynamic_dispatch**,
**generics**, **function_pointers**, **conditionally_compiled** and **macros**.

Splitting the code across multiple packages and library crates allows for better code organization,
but also for opportunities to assess how call graph generators analyze and resolve cross-package
calls.

### main
- Crates:
    1 binary
- Depends on:
    **traits**, **structs**, **static_dispatch**, **dynamic_dispatch**, **generics**,
    **function\_pointers**, **conditionally\_compiled**, **macros**
- Description:
    Main benchmark code. Calls the benchmarks defined in the supporting benchmark packages.

### traits
- Crates:
    1 library
- Depends on:
    nothing
- Description:
    Trait definitions used by the different benchmark libraries.

### structs
- Crates:
    1 library
- Depends on:
    **traits**
- Description:
    Struct definitions. Struct and trait implementations.
- Call examples:
```rust
pub struct Two(i32);

impl Two {
    pub fn method_1(&self) -> i32 {
        self.0 + 1
    }

    pub fn method_2(&mut self) -> i32 {
        // instance method call (inherent)
        // structs::lib::Two::add_one
        // Call to inherent private method inside another method.
        self.add_one();

        // instance method call (inherent)
        // structs::lib::Two::method_1
        // Call to inherent public method inside another method.
        self.method_1()
    }

    fn add_one(&mut self) {
        self.0 = self.0 + 1;
    }
}
```

### static\_dispatch
- Crates:
    1 library
- Depends on:
    **traits**, **structs**
- Description:
    Static and instance method calls implemented directly on type `T` or provided by a trait
    implemented by `T`. Test cases that target different calling conventions but also touch upon
    static method resolution and lookup.
- Call examples:
```rust
use structs::lib::One;
use structs::lib::Two;

// static method call (inherent)
// structs::lib::One::method_1
One::method_1();

// instance method call (inherent)
// structs::lib::One::method_2
let mut one = One;
one.method_2();

// instance method call (inherent)
// structs::lib::One::method_2
// Generates slightly different mir code than 'one.method_2()'.
One.method_2();

// static method call (inherent)
// structs::lib::Two::new
// Returns the Self type.
let mut two = Two::new(0);

// instance method call (inherent)
// structs::lib::Two::method_1
// Same name as structs::lib::One::method_1 but different signature and definition path.
two.method_1();

// instance method call (inherent)
// structs::lib::Two::method_2
// Same name and signature as structs::lib::One::method_2 but different definition path.
two.method_2();
```

```rust
use structs::lib::fat::Fat;
use traits::lib::FooTrait;
use traits::lib::BarTrait;

let fat = Fat(100);

// instance method call (inherent)
// structs::lib::fat::Fat::method
// Method lookup should resolve this call to structs::lib::fat::Fat::method and not to the methods
// defined in the implementations of FooTrait or BarTrait by Fat
// (https://doc.rust-lang.org/reference/expressions/method-call-expr.html).
fat.method();

// instance method call (trait)
// structs::lib::fat::{impl FooTrait for Fat}::method
// Fully qualified syntax call circumvents method lookup.
FooTrait::method(&fat);

// instance method call (trait)
// structs::lib::fat::{impl BarTrait for Fat}::method
// Fully qualified syntax `<T as TraitRef>::item` circumvents method lookup.
<Fat as BarTrait>::method(&fat);

// instance method call (trait)
// structs::lib::fat::{impl BarTrait for Fat}::yet_another_method
// Method structs::lib::fat::Fat::yet_another_method is not public, thus the call to
// yet_another_method is resolved to that of BarTrait's implementation by Fat.
fat.yet_another_method();
```

### dynamic\_dispatch
- Crates:
    1 library
- Depends on:
    **structs**, **traits**
- Description:
    Trait objects and dynamic dispatch.
- Call examples:
```rust
use traits::lib::FooTrait;

// 'dynamic*' functions accept as argument a trait object of type traits::lib::FooTrait and
// call 'method' on it. Dynamic dispatch is used to resolve these method calls.
fn dynamic(x: &dyn FooTrait) -> u32 {
    // instance method call (trait)
    // traits::lib::FooTrait::method
    // Dynamic dispatch.
    x.method()
}

fn dynamic_ufcs(x: &dyn FooTrait) -> u32 {
    // instance method call (trait)
    // traits::lib::FooTrait::method
    // Dynamic dispatch with fully qualified syntax.
    FooTrait::method(x)
}

fn test() {
    use structs::lib::fat::Fat;
    use structs::lib::thin::Thin;

    let fat = Fat(10);

    // static function call
    // dynamic_dispatch::lib::dynamic
    // The dynamic dispatch call happens inside function 'dynamic'.
    dynamic(&fat);  // &my_int is coerced to &FooTrait

    // static function call
    // dynamic_dispatch::lib::dynamic_ufcs
    // Casting to &dyn FooTrait generates slightly more MIR code to account for the cast
    // operation. We include it along the coercion version for completeness.
    dynamic_ufcs(&fat as &dyn FooTrait);  // &my_int is casted to &FooTrait

    let thin = Thin;
    let vec: Vec<&dyn FooTrait> = vec![&fat, &thin];

    for item in vec.iter() {
        // instance method call (trait)
        // traits::lib::FooTrait::method
        // Dynamic dispatch on referenced vector elements.
        item.method();
    }
}
```

### generics
- Crates:
    1 library
- Depends on:
    **structs**, **traits**
- Description:
    Generic functions with trait bounds. At compile time, this generic code
    is monomorphized.
- Call examples:
```rust
```

### function\_pointers
- Crates:
    1 library
- Depends on:
    **structs**
- Description:
    Function pointer types declarations.
- Call examples:
```rust
```

### conditionally\_compiled
- Crates:
    1 library
- Depends on:
    **structs**
- Description:
    Conditionally compiled functions.
- Call examples:
```rust
```

### macros
- Crates:
    1 library
- Depends on:
    **structs**
- Description:
    Function and method calls inside macros.
- Call examples:
```rust
```

### default
 - Crates:
    1 library
 - Depends on:
    *nothing*
 - Description:
    Default trait methods. These could be part of the 'traits' module of the
    **structs** crate, but we choose to introduce them as part of another crate
    on which **structs** depends. This artificial dependency is introduced to
    include transitive crate dependencies in the benchmark.
