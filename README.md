# Rust Call-Graph Generator Benchmark

A benchmark for call-graph generators that analyze programs written in Rust. This benchmark is a
collection of hopefully all the possible ways to call a function or a method within and across
package boundaries in Rust.

This benchmark aims to enable call-graph generator implementers to assess the soundness of
call-graphs generated by their tools. It can also serve as documentation of all the possible ways
functions and methods may be called in Rust code.

## Benchmark Structure

The benchmark is built around the **main** package, which contains a single binary crate. The
benchmark is organized in several packages, each one containing a subset of the available ways to
call a function/method. These packages are **static_dispatch**, **dynamic_dispatch**,
**generics**, **function_pointers**, **conditionally_compiled** and **macros**.

Splitting the code across multiple packages and library crates allows for better code organization,
but also for opportunities to assess how call graph generators analyze and resolve cross-package
calls.

### main
- Crates:
    1 binary
- Depends on:
    **traits**, **structs**, **static_dispatch**, **dynamic_dispatch**, **generics**,
    **function\_pointers**, **conditionally\_compiled**, **macros**
- Description:
    Main benchmark code. Calls the benchmarks defined in the supporting benchmark packages.

### traits
- Crates:
    1 library
- Depends on:
    nothing
- Description:
    Trait definitions used by the individual benchmarks.

### structs
- Crates:
    1 library
- Depends on:
    **traits**
- Description:
    Struct definitions and struct and trait implementations used by the individual benchmarks.
- Call examples:
    * Call to inherent public method inside another method.
    * Call to inherent private method inside another method.

### static\_dispatch
- Crates:
    1 library
- Depends on:
    **traits**, **structs**
- Description:
    Static and instance method calls implemented directly on type `T` or provided by a trait
    implemented by `T`. Test cases that target different calling conventions but also touch upon
    static method resolution and lookup.
- Call examples:
    * Static method call (inherent).
    * Instance method call (inherent).
    * Instance method call (inherent) on newly allocated object.
    * Instance method call (trait) using fully qualified syntax.

### dynamic\_dispatch
- Crates:
    1 library
- Depends on:
    **structs**, **traits**
- Description:
    Trait objects and dynamic dispatch.
- Call examples:
    * Dynamic dispatch.
    * Dynamic dispatch (qualified syntax).
    * Dynamic dispatch on generic trait object.
    * Dynamic dispatch on referenced vector elements.

### generics
- Crates:
    1 library
- Depends on:
    **structs**, **traits**
- Description:
    Generic trait bounded functions and structs that are monomorphized during compilation.
- Call examples:
    * Call on generic type receiver (trait bounded).
    * Call on generic type receiver (trait bounded by a generic trait).
    * Call on generic type receiver (trait bounded by a generic trait which is concretized).

### function\_pointers
- Crates:
    1 library
- Depends on:
    **structs**
- Description:
    Function pointer and Fn trait instance calls.
- Call examples:
    * Call via function pointer.
    * Call via generic function pointer.
    * Call of an Fn trait instance.

### conditionally\_compiled
- Crates:
    1 library
- Depends on:
    **structs**
- Description:
    Conditionally compiled functions.

### macros
- Crates:
    1 library
- Depends on:
    **structs**
- Description:
    Function and method calls inside macros.
- Call examples:
    * Call inside declarative macro.
    * Method definition and call generated by derive macro.
