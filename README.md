# Rust Call-Graph Generator Benchmark

A benchmark for call-graph generators that analyze programs written in Rust. This benchmark is a
collection of hopefully all the possible ways to call a function or a method within and across
package boundaries in Rust.

This benchmark aims to enable call-graph generator implementers to assess the soundness of
call-graphs generated by their tools. It can also serve as documentation of all the possible ways
functions and methods may be called in Rust code.

## Benchmark Structure

The benchmark is built around the **main** package, which contains a single binary crate. To assess
how cross-package calls are analyzed by call-graph generators we split the code across multiple
library crates and packages. The **main** crate calls the functions and methods of these packages.
Calls within package boundaries are also covered by most of the packages.

### main
- Crates:
    1 binary
- Depends on:
    **traits**, **structs**, **static_dispatch**, **dynamic_dispatch**, **generics**,
    **function\_pointers**, **conditionally\_compiled**, **macros**
- Description:
    Main benchmark code. Calls the benchmarks defined in the supporting benchmark packages.

### traits
- Crates:
    1 library
- Depends on:
    nothing
- Description:
    Trait definitions used by the different benchmark libraries.

### structs
- Crates:
    1 library
- Depends on:
    **traits**
- Description:
    Struct definitions. Struct and trait implementations.
- Call examples:
```rust
pub struct Two(i32);

impl Two {
    pub fn method_1(&self) -> i32 {
        self.0 + 1
    }

    pub fn method_2(&mut self) -> i32 {
        // instance method call (inherent)
        // structs::lib::Two::add_one
        // Call to inherent private method inside another method.
        self.add_one();

        // instance method call (inherent)
        // structs::lib::Two::method_1
        // Call to inherent public method inside another method.
        self.method_1()
    }

    fn add_one(&mut self) {
        self.0 = self.0 + 1;
    }
}
```

### static\_dispatch
- Crates:
    1 library
- Depends on:
    **traits**, **structs**
- Description:
    Static and instance method calls implemented directly on type `T` or provided by a trait
    implemented by `T`. Test cases that target different calling conventions but also touch upon
    static method resolution and lookup.
- Call examples:
```rust
use structs::lib::One;
use structs::lib::Two;

// static method call (inherent)
// structs::lib::One::method_1
One::method_1();

// instance method call (inherent)
// structs::lib::One::method_2
let mut one = One;
one.method_2();

// instance method call (inherent)
// structs::lib::One::method_2
// Generates slightly different mir code than 'one.method_2()'.
One.method_2();

// static method call (inherent)
// structs::lib::Two::new
// Returns the Self type.
let mut two = Two::new(0);

// instance method call (inherent)
// structs::lib::Two::method_1
// Same name as structs::lib::One::method_1 but different signature and definition path.
two.method_1();

// instance method call (inherent)
// structs::lib::Two::method_2
// Same name and signature as structs::lib::One::method_2 but different definition path.
two.method_2();
```

```rust
use structs::lib::fat::Fat;
use traits::lib::FooTrait;
use traits::lib::BarTrait;

let fat = Fat(100);

// instance method call (inherent)
// structs::lib::fat::Fat::method
// Method lookup should resolve this call to structs::lib::fat::Fat::method and not to the methods
// defined in the implementations of FooTrait or BarTrait by Fat
// (https://doc.rust-lang.org/reference/expressions/method-call-expr.html).
fat.method();

// instance method call (trait)
// structs::lib::fat::{impl FooTrait for Fat}::method
// Fully qualified syntax call circumvents method lookup.
FooTrait::method(&fat);

// instance method call (trait)
// structs::lib::fat::{impl BarTrait for Fat}::method
// Fully qualified syntax `<T as TraitRef>::item` circumvents method lookup.
<Fat as BarTrait>::method(&fat);

// instance method call (trait)
// structs::lib::fat::{impl BarTrait for Fat}::yet_another_method
// Method structs::lib::fat::Fat::yet_another_method is not public, thus the call to
// yet_another_method is resolved to that of BarTrait's implementation by Fat.
fat.yet_another_method();
```

### dynamic\_dispatch
- Crates:
    1 library
- Depends on:
    **structs**
- Description:
    Trait objects and dynamic dispatch.
- Call examples:
```rust
```

### generics
- Crates:
    1 library
- Depends on:
    *nothing*
- Description:
    Generic functions with trait bounds. At compile time, this generic code
    is monomorphized.
- Call examples:
```rust
```

### function\_pointers
- Crates:
    1 library
- Depends on:
    **structs**
- Description:
    Function pointer types declarations.
- Call examples:
```rust
```

### conditionally\_compiled
- Crates:
    1 library
- Depends on:
    **structs**
- Description:
    Conditionally compiled functions.
- Call examples:
```rust
```

### macros
- Crates:
    1 library
- Depends on:
    **structs**
- Description:
    Function and method calls inside macros.
- Call examples:
```rust
```

### default
 - Crates:
    1 library
 - Depends on:
    *nothing*
 - Description:
    Default trait methods. These could be part of the 'traits' module of the
    **structs** crate, but we choose to introduce them as part of another crate
    on which **structs** depends. This artificial dependency is introduced to
    include transitive crate dependencies in the benchmark.
